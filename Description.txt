Проект должен был представлять собой примитивную CRM с регистрацией, аутентификацией,созданием заказов и выдачи отсортированного по имени клиента или цене списка заказов.
Состав заказа "имя клиента, цена, описание заказа"
Формат передаваемых от клиента команд типа 
"id:номер айди;command: тип команды;data: данныt команды;"
данные команды имеют формат type1=data1&type2=data2.....
Номер айди это номер сессии
command может принимать занчения команды регистрации, авторизации, поступления заказа, запроса массива заказов в том числе отсортированных
структуру команды парсит самописный парсер
струткру данныхпарсит boost;

К сожалению реализовнные вначале примеры работы с сокетами подкупили своей простотой и отложились на конец. Однако,почему то, реализовннаые в дальнейшем примеры показали свою 
нестабильность (лез какой то мусор) поэтому от идеи их реализации пришлось отказаться до дальнейшего более глубоко изучения. Программа в итоге имеет одно терминальное окно с пользовательстким 
клиентским интерфеейсом и эмуляцией работы сервера. Соотеветсвенно без рабочих сокетов не было смысла дописывать процедуры регистрации и пр. Оставшийся функционал позволяет создавать заказы и
получать их перечень.



1.Классы, относящиеся к серверной части:
 Processor, Encryptor, GammaEncryptor, Authentificator(Не используется)
Реализует обработку поступающих сообщений.их декодирование посредством метода абстрактного класса Encryptor, 
пасинг и вызов соответствующих команд.
Заложено:
1.1 Регистрация новых пользоватлей и аутентификация существующих в оперативной базе данных пользователей и пародей 
на основе std::map в классе Authentifictor
1.2 Оперативная база сессий на основе Processor::sessionMap и методы работы с ней (void Processor::appendSession(string user, string id);
	и void Processor::eraseSession(string id);
1.3 Самописный рекурсивный парсер команд void  Processor::parse(char extDivider, char intDivider, std::string& flow, int pos, map<string, string>& flowMap);
1.4 метод расшифровки полученный соообщений void Processor::decrypt(string keyName, string& cString);
1.5 Методы сравнения структур типа struct order {
	std::string price;
	std::string client;
	std::string toDo;
}; по цене и по имени клиенат. Изначально цена была типа int. Поэтому создал два метода. Потом изменил на std::srtring, но удалять не стал, тем более, что один метод в итоге не использовал,
заменив его на лямбда-выражение
1.6 Шаблонную функцию сортировки void Sort(vector<T>& arr, Compare cmp);
	использую эту функцию два раза: для сортивроки по клиентам, реализуя коолбэквызов через std::function<bool(order,order)> cmp и 
	второй раз, также реализую коллбэквызов через лямбда выражение.
1.7  Метод std::string joinOrders(const vector<order> orders) объединяет строки и использует спецификатор const. Тот же const можно было много еще где использовать
но программа небольшая и я не волновался по поводу безопасноти использования. Тот же вектор можно было выделить динамически при допущениии что он будет достаточно большим.
1.8 Метод void Processor::ProcessMsg(std::string data) дешифрует получаемые данные, дешифрует , парсит и выполняет заложенные команды. Именно он должен был получать данные из сокета
и отправлять данные в метод void out(std::string data); 
1.9 шифратор и дешифратор описыват абстрактный класс Encryptor, содержащий однако общую для всех шифраторов базу данных ключей. Его наследует класс Gammaencryptor, который
определяет его методы шифрования и дешифрования (примитивным наложеним ключа по модулю 2).
кроме самописного парсера используется библиотека boost для работы с регулярными выражениями.

2. Классы, относящиеся к клиентской части Controller, Userinterface,Encryptor, GammaEncryptor
Класс  Userinterface реализует пользовательский интерфейс из которого сипользуется только создание заявки и получение сортировки.
Класс Controller должен был сопрячь клиентский сокет с пользовательским интерфейсом, формирование команди их оотправку.

Итого: 
-абстрактный класс реализован в Encryptor, его наследует GammaEncryptor
- callback функция задействована в void Processor::ProcessMsg(std::string data)
- сортировка релизована в void Sort(vector<T>& arr, Compare cmp) (признаюсь, шаблон мой а алгоритм сортировки скопировал для быстроты отладки, , проблем с написанием своего не вижу)
- std::vector и(или) std::map почти везде
- рекурсия в методе void  Processor::parse(char extDivider, char intDivider, std::string& flow, int pos, map<string, string>& flowMap)
- ссылки там же и много где еще (где const не ставил так как компилятор, на сколько я знаю в этом случае также использует ссылки)
- указатель используется в Controller::Controller(),уничтожается привыходе из программы.
- static использщуется в Processor
- перегрузка фунций не используется.


несмотря на результаты оценки тестового задания, буду благодарен, если порекомендуете толковые источники для дальнейшего изучения. 